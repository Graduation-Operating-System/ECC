기존 Concept of ECC 알고리즘에서 발생한 해저드

1. 구조적 해저드 (Structural Hazard)
구조적 해저드는 하드웨어 자원이 부족하여 발생하는 해저드이다. 이 코드는 소프트웨어 레벨에서 작성된 것이기 때문에, 직접적으로 구조적 해저드는 발생하지 않는다. 그러나 구조적 해저드가 발생할 수 있는 상황을 고려할 수 있다.

예시: 하드웨어에서 동시에 여러 연산을 수행할 수 없는 경우. 예를 들어, CPU가 한 번에 한 개의 모듈로 연산만 처리할 수 있다면, add 함수와 modInverse 함수가 동시에 호출될 때 충돌이 발생할 수 있다. 하지만 이는 소프트웨어 코드 자체의 문제는 아니다.

2. 데이터 해저드 (Data Hazard)
데이터 해저드는 명령어 간의 데이터 의존성으로 인해 발생하는 해저드이다. 이 코드에서의 데이터 해저드는 다음과 같은 상황으로 설명할 수 있다.

예시: add 함수 내에서 lambda를 계산할 때, modInverse 함수의 결과에 의존한다. 만약 modInverse가 비동기적으로 호출되거나 결과를 기다리는 동안 다른 연산이 수행된다면, 잘못된 결과가 나올 수 있다.
해결 방법: 이러한 데이터 의존성을 줄이기 위해 명령어의 순서를 조정하거나, 필요한 값을 미리 계산하여 재사용하는 방법을 고려할 수 있다.

3. 제어 해저드 (Control Hazard)
제어 해저드는 분기 명령이나 반복 구조와 관련된 해저드이다. 이 코드에서 제어 해저드는 다음과 같은 경우에 발생할 수 있다.

예시: scalarMultiply 함수에서 for 루프가 반복될 때, k의 값이 동적으로 변경되면 루프의 종료 조건이 영향을 받을 수 있다. 특히, 만약 k가 외부에서 비동기적으로 수정된다면, 루프의 실행 결과가 예측할 수 없게 된다.
해결 방법: k의 값을 함수 매개변수로 받아서 해당 함수 내에서만 사용하도록 하여 제어 흐름을 명확하게 하고, 외부에서의 수정 가능성을 줄이는 것이 좋습니다.

파악한 해저드를 해결하기 위해 재작성한 코드:

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int x;
    int y;
} Point;

typedef struct {
    int a;
    int b;
    int p; // 소수
} EllipticCurve;

// 모듈로 역수 계산 (확장 유클리드 알고리즘)
int modInverse(int a, int p) {
    int m0 = p, t, q;
    int x0 = 0, x1 = 1;

    if (p == 1) return 0;

    while (a > 1) {
        q = a / p;
        t = p;
        p = a % p;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0) x1 += m0;

    return x1;
}

// 점 덧셈
Point add(Point P, Point Q, EllipticCurve curve) {
    if (P.x == 0 && P.y == 0) return Q;
    if (Q.x == 0 && Q.y == 0) return P;

    if (P.x == Q.x && P.y == Q.y) {
        // 점이 동일할 때의 처리 (접선의 기울기 계산)
        int lambda = (3 * P.x * P.x + curve.a) * modInverse(2 * P.y, curve.p) % curve.p;
        int xR = (lambda * lambda - 2 * P.x) % curve.p;
        int yR = (lambda * (P.x - xR) - P.y) % curve.p;
        return (Point){(xR + curve.p) % curve.p, (yR + curve.p) % curve.p};
    }

    int lambda = (Q.y - P.y) * modInverse(Q.x - P.x, curve.p) % curve.p;
    int xR = (lambda * lambda - P.x - Q.x) % curve.p;
    int yR = (lambda * (P.x - xR) - P.y) % curve.p;

    return (Point){(xR + curve.p) % curve.p, (yR + curve.p) % curve.p};
}

// 스칼라 곱셈 (이진법 사용)
Point scalarMultiply(Point P, int k, EllipticCurve curve) {
    Point R = {0, 0}; // 무한대 점
    Point Q = P; // 현재 점

    while (k > 0) {
        if (k % 2 == 1) {
            R = add(R, Q, curve);
        }
        Q = add(Q, Q, curve); // Q = 2Q
        k /= 2;
    }
    return R;
}

int main() {
    EllipticCurve curve = {2, 3, 97}; // y^2 = x^3 + 2x + 3 (mod 97)
    Point P = {3, 6};
    Point Q = {10, 7};

    Point R = add(P, Q, curve);
    printf("P + Q = (%d, %d)\n", R.x, R.y);

    int k = 2;
    Point S = scalarMultiply(P, k, curve);
    printf("2P = (%d, %d)\n", S.x, S.y);

    return 0;
}

개선된 코드의 주요 특징
모듈로 역수 계산: 확장 유클리드 알고리즘을 통해 효율적으로 모듈로 역수를 계산한다.
동일한 점 처리: 점이 동일할 경우의 특별한 처리를 추가하여 적절한 기울기를 계산한다.
스칼라 곱셈 최적화: 이진법을 활용하여 스칼라 곱셈을 O(log k) 복잡도로 효율적으로 수행한다.
